#!/usr/bin/env ruby

# -------------------------------------------------------------------------- #
# Copyright 2010-2013, C12G Labs S.L.                                        #
#                                                                            #
# Licensed under the Apache License, Version 2.0 (the "License"); you may    #
# not use this file except in compliance with the License. You may obtain    #
# a copy of the License at                                                   #
#                                                                            #
# http://www.apache.org/licenses/LICENSE-2.0                                 #
#                                                                            #
# Unless required by applicable law or agreed to in writing, software        #
# distributed under the License is distributed on an "AS IS" BASIS,          #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   #
# See the License for the specific language governing permissions and        #
# limitations under the License.                                             #
#--------------------------------------------------------------------------- #

ONE_LOCATION=ENV["ONE_LOCATION"]

if !ONE_LOCATION
    RUBY_LIB_LOCATION="/usr/lib/one/ruby"
else
    RUBY_LIB_LOCATION=ONE_LOCATION+"/lib/ruby"
end

$: << RUBY_LIB_LOCATION
$: << RUBY_LIB_LOCATION+'/cli'

require 'oneapps/flow/appflow_client'
require 'oneapps/version'

require 'command_parser'
require 'cli_helper'
require 'one_helper/onevm_helper'

require 'json'

USER_AGENT = "CLI"

# Base Path representing the resource to be used in the requests
RESOURCE_PATH = "/service"

#
# Table
#

SERVICE_TABLE = CLIHelper::ShowTable.new(nil, self) do
    column :ID, "ID", :size=>10 do |d|
        d["ID"]
    end

    column :USER, "Username", :left, :size=>15 do |d|
        d["UNAME"]
    end

    column :GROUP, "Group", :left, :size=>15 do |d|
        d["GNAME"]
    end

    column :NAME, "Name", :size=>25, :left=>true do |d|
        d["NAME"]
    end

    column :STATE, "State", :size=>11, :left=>true do |d|
        Service.state_str(d["TEMPLATE"]["BODY"]['state'])
    end

    default :ID, :USER, :GROUP, :NAME, :STATE
end

NODE_TABLE = CLIHelper::ShowTable.new(nil, self) do
    column :VM_ID, "ONE identifier for Virtual Machine", :size=>6 do |d|
        d['vm_info']['VM']["ID"]
    end

    column :NAME, "Name of the Virtual Machine", :left,
            :size=>23 do |d|
        if d['vm_info']['VM']["RESCHED"] == "1"
            "*#{d["NAME"]}"
        else
            d['vm_info']['VM']["NAME"]
        end
    end

    column :USER, "Username of the Virtual Machine owner", :left,
            :size=>8 do |d|
        d['vm_info']['VM']["UNAME"]
    end

    column :GROUP, "Group of the Virtual Machine", :left,
            :size=>8 do |d|
        d['vm_info']['VM']["GNAME"]
    end

    column :STAT, "Actual status", :size=>4 do |d,e|
        OneVMHelper.state_to_str(d['vm_info']['VM']["STATE"], d['vm_info']['VM']["LCM_STATE"])
    end

    column :UCPU, "CPU percentage used by the VM", :size=>4 do |d|
        d['vm_info']['VM']["CPU"]
    end

    column :UMEM, "Memory used by the VM", :size=>7 do |d|
        OpenNebulaHelper.unit_to_str(d['vm_info']['VM']["MEMORY"].to_i, {})
    end

    column :HOST, "Host where the VM is running", :left, :size=>20 do |d|
        if d['vm_info']['VM']['HISTORY_RECORDS'] && d['vm_info']['VM']['HISTORY_RECORDS']['HISTORY']
            state_str = VirtualMachine::VM_STATE[d['vm_info']['VM']['STATE'].to_i]
            if %w{ACTIVE SUSPENDED}.include? state_str
                history = if d['vm_info']['VM']['HISTORY_RECORDS']['HISTORY'].instance_of?(Array)
                    d['vm_info']['VM']['HISTORY_RECORDS']['HISTORY'].last
                else
                    d['vm_info']['VM']['HISTORY_RECORDS']['HISTORY']
                end

                history['HOSTNAME']
            end
        end
    end

    column :TIME, "Time since the VM was submitted", :size=>10 do |d|
        stime = d['vm_info']['VM']["STIME"].to_i
        etime = d['vm_info']['VM']["ETIME"]=="0" ? Time.now.to_i : d['vm_info']['VM']["ETIME"].to_i
        dtime = etime-stime
        OpenNebulaHelper.period_to_str(dtime, false)
    end

    default :VM_ID, :NAME, :STAT, :UCPU, :UMEM, :HOST, :TIME
end

# List the services. This method is used in top and list commands
# @param [Service::Client] client
# @param [Array] args
# @param [Hash] options
# @return [[Integer, String], Integer] Returns the exit_code and optionally
#   a String to be printed
def list_services(client, args, options)
    response = client.get(RESOURCE_PATH)

    if CloudClient::is_error?(response)
        [response.code.to_i, response.to_s]
    else
        #[0,response.body]
        if options[:json]
            [0,response.body]
        else
            array_list = JSON.parse(response.body)
            SERVICE_TABLE.show(array_list['DOCUMENT_POOL']['DOCUMENT'])
            0
        end
    end
end

# Show the service information. This method is used in top and show commands
# @param [Service::Client] client
# @param [Array] args
# @param [Hash] options
# @return [[Integer, String], Integer] Returns the exit_code and optionally
#   a String to be printed
def show_service(client, args, options)
    response = client.get("#{RESOURCE_PATH}/#{args[0]}")

    if CloudClient::is_error?(response)
        [response.code.to_i, response.to_s]
    else
        #[0,response.body]
        if options[:json]
            [0,response.body]
        else
            str="%-20s: %-20s"
            str_h1="%-80s"

            document_hash = JSON.parse(response.body)
            template = document_hash['DOCUMENT']['TEMPLATE']['BODY']

            CLIHelper.print_header(str_h1 % "SERVICE #{document_hash['DOCUMENT']['ID']} INFORMATION")

            puts str % ["ID",   document_hash['DOCUMENT']['ID']]
            puts str % ["NAME", document_hash['DOCUMENT']['NAME']]
            puts str % ["USER", document_hash['DOCUMENT']['UNAME']]
            puts str % ["GROUP",document_hash['DOCUMENT']['GNAME']]

            puts str % ["STRATEGY", template['deployment']]
            puts str % ["SERVICE STATE", Service.state_str(template['state'])]

            puts

            CLIHelper.print_header(str_h1 % "PERMISSIONS",false)

            ["OWNER", "GROUP", "OTHER"].each { |e|
                mask = "---"
                mask[0] = "u" if document_hash['DOCUMENT']['PERMISSIONS']["#{e}_U"] == "1"
                mask[1] = "m" if document_hash['DOCUMENT']['PERMISSIONS']["#{e}_M"] == "1"
                mask[2] = "a" if document_hash['DOCUMENT']['PERMISSIONS']["#{e}_A"] == "1"

                puts str % [e,  mask]
            }

            puts

            template['roles'].each {|role|
                CLIHelper.print_header("ROLE #{role['name']}", false)

                puts str % ["ROLE STATE", Role.state_str(role['state'])]
                puts str % ["PARENTS", role['parents'].join(', ')] if role['parents']
                puts str % ["CARNIDALITY", role['cardinality']||1]
                puts str % ["VM TEMPLATE", role['vm_template']]

                puts "NODES INFORMATION"
                NODE_TABLE.show(role['nodes'])
                puts
            }

            puts

            CLIHelper.print_header(str_h1 % "LOG MESSAGES",false)

            if template['log']
                template['log'].each { |log|
                    t = Time.at(log['timestamp']).strftime("%m/%d/%y %H:%M")
                    puts "#{t} [#{log['severity']}] #{log['message']}"
                }
            end

            0
        end
    end
end

#
# Commands
#

cmd=CommandParser::CmdParser.new(ARGV) do
    usage "`appflow` <command> [<args>] [<options>]"
    version OneApps::VERSION_TEXT

    set :option, Service::DEFAULT_OPTIONS 
    set :option, CommandParser::VERSION

    #
    # Formatters for arguments
    #
    set :format, :groupid, OpenNebulaHelper.rname_to_id_desc("GROUP") do |arg|
        OpenNebulaHelper.rname_to_id(arg, "GROUP")
    end

    set :format, :userid, OpenNebulaHelper.rname_to_id_desc("USER") do |arg|
        OpenNebulaHelper.rname_to_id(arg, "USER")
    end

    set :format, :serviceid, Service.rname_to_id_desc("SERVICE") do |arg|
        Service.rname_to_id(arg, "SERVICE")
    end

    set :format, :serviceid_list, Service.list_to_id_desc("SERVICE") do |arg|
        Service.list_to_id(arg, "SERVICE")
    end

    #
    # List
    #

    list_desc = <<-EOT.unindent
        List the available services
    EOT

    command :list, list_desc, :options => Service::JSON_FORMAT do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        list_services(client, args, options)
    end

    #
    # Show
    #

    show_desc = <<-EOT.unindent
        Show detailed information of a given service
    EOT

    command :show, show_desc, :serviceid, :options => Service::JSON_FORMAT do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        show_service(client, args, options)
    end

    #
    # Top
    #

    top_desc = <<-EOT.unindent
        Top the services or the extended information of the target service if a
        id is specified
    EOT

    command :top, top_desc, [:serviceid, nil],
            :options => [Service::JSON_FORMAT, Service::TOP, CLIHelper::DELAY] do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        delay=options[:delay] ? options[:delay] : 3

        begin
            while true
                CLIHelper.scr_cls
                CLIHelper.scr_move(0,0)

                if args[0]
                    rc, message = show_service(client, args, options)

                    if rc != 0
                        raise message
                    end
                else
                    rc, message = list_services(client, args, options)

                    if rc != 0
                        raise message
                    end
                end

                sleep delay
            end
        rescue Exception => e
            puts e.message
            -1
        end
    end

    #
    # Delete
    #

    delete_desc = <<-EOT.unindent
        Delete a given service
    EOT

    command :delete, delete_desc, [:range, :serviceid_list] do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        Service.perform_actions(args[0]) { |service_id|
            client.delete("#{RESOURCE_PATH}/#{service_id}")
        }
    end

    #
    # Shutdown
    #

    shutdown_desc = <<-EOT.unindent
        Shutdown a service.
            From RUNNING or UNKNOWN shutdowna the Service
            From FAILED_UNDEPLOYING continues shutting down the Service
    EOT

    command :shutdown, shutdown_desc, [:range, :serviceid_list] do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        Service.perform_actions(args[0]) { |service_id|
            json_action = Service.build_json_action('shutdown')

            client.post("#{RESOURCE_PATH}/#{service_id}/action", json_action)
        }
    end

    #
    # Deploy
    #

    deploy_desc = <<-EOT.unindent
        Deploy a service
            From FAILED_DEPLOYING continues deploying the Service
    EOT

    command :deploy, deploy_desc, [:range, :serviceid_list] do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        Service.perform_actions(args[0]) { |service_id|
            json_action = Service.build_json_action('deploy')

            client.post("#{RESOURCE_PATH}/#{service_id}/action", json_action)
        }
    end

    chgrp_desc = <<-EOT.unindent
        Changes the service group
    EOT

    command :chgrp, chgrp_desc, [:range, :serviceid_list], :groupid do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        Service.perform_actions(args[0]) { |service_id|
            params = Hash.new
            params['group_id'] = args[1].to_i

            json_action = Service.build_json_action('chgrp', params)

            client.post("#{RESOURCE_PATH}/#{service_id}/action", json_action)
        }
    end

    chown_desc = <<-EOT.unindent
        Changes the service owner and group
    EOT

    command :chown, chown_desc, [:range, :serviceid_list], :userid, [:groupid, nil] do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        Service.perform_actions(args[0]) { |service_id|
            params = Hash.new
            params['owner_id'] = args[1]
            params['group_id'] = args[2] if args[2]

            json_action = Service.build_json_action('chown', params)

            client.post("#{RESOURCE_PATH}/#{service_id}/action", json_action)
        }
    end

    chmod_desc = <<-EOT.unindent
        Changes the service permissions
    EOT

    command :chmod, chmod_desc, [:range, :serviceid_list], :octet do
        client = Service::Client.new(
                    :username   => options[:username],
                    :password   => options[:password],
                    :url        => options[:server],
                    :user_agent => USER_AGENT)

        Service.perform_actions(args[0]) { |service_id|
            params = Hash.new
            params['octet'] = args[1]

            json_action = Service.build_json_action('chmod', params)

            client.post("#{RESOURCE_PATH}/#{service_id}/action", json_action)
        }
    end
end